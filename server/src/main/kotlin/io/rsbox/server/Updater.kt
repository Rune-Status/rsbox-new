package io.rsbox.server

import com.google.common.base.Stopwatch
import com.uchuhimo.konf.Config
import io.rsbox.config.Conf
import io.rsbox.config.PathConstants
import io.rsbox.config.specs.ServerSpec
import mu.KLogging
import java.io.File
import java.io.FileOutputStream
import java.net.URL
import java.nio.channels.Channels
import java.util.*
import java.util.concurrent.TimeUnit
import java.util.zip.ZipFile
import kotlin.system.exitProcess

/**
 * @author Graviton #1697
 */

object Updater : KLogging() {

    var stopwatch = Stopwatch.createStarted()
    var version = 0

    private fun needsUpdate() : Boolean {
        val result = URL(PathConstants.ASSETS_REPO).readText()
        val nextRevision = Conf.SERVER[ServerSpec.revision] + 1
        version = nextRevision
        return Conf.SERVER[ServerSpec.automatic_update] && result.contains(nextRevision.toString())
    }

    fun check() {
        if(needsUpdate()) {
            update()
        } else {
            logger.info("No updates available.")
        }
    }

    private fun update() {
        if(Conf.SERVER[ServerSpec.prompt_update]) {
            val s = Scanner(System.`in`)
            var input = true
            while (input) {
                logger.info("Would you like to update to $version [y/n]")
                input = when (s.nextLine()) {
                    "y" -> {
                        run()
                        false
                    }
                    "n" -> false
                        else -> {
                            print("Please enter y or n [y = Yes] [n = No]")
                            true
                     }
                }
            }
        } else {
            run()
        }

    }

    private fun run() {
        logger.info("Preparing to update ${Conf.SERVER[ServerSpec.name]} [0/4]")
        this.downloadCache()
    }

    private fun downloadCache() {
        logger.info("Downloading Cache... [1/4]")
        stopwatch.reset()
        stopwatch = Stopwatch.createStarted()
        val channel = Channels.newChannel(URL(PathConstants.CACHE_REPO.replace("<>", Config{addSpec(ServerSpec)}[ServerSpec.revision].toString())).openStream())
        val output = FileOutputStream("${PathConstants.CACHE_PATH}cache.zip")
        val fileChannel = output.channel
        fileChannel.transferFrom(channel, 0, Long.MAX_VALUE)

        this.downloadXteas()
    }

    private fun downloadXteas() {
        logger.info("Downloading Xteas... [2/4]")
        val channel = Channels.newChannel(URL(PathConstants.XTEAS_REPO.replace("<>", Config{addSpec(ServerSpec)}[ServerSpec.revision].toString())).openStream())
        val output = FileOutputStream(PathConstants.XTEAS_FILE_PATH)
        output.channel.transferFrom(channel, 0, Long.MAX_VALUE)

        this.extractCache()
    }

    private fun extractCache() {
        var filesdone : Int = 0
        logger.info("Decompressing cache files... [3/4]")
        val file = File("${PathConstants.CACHE_PATH}cache.zip")
        ZipFile(file).use { zip ->
            zip.entries().asSequence().forEach { entry ->
                zip.getInputStream(entry).use { input ->
                    File("${PathConstants.CACHE_PATH}${entry.name}").outputStream().use { output ->
                        filesdone++
                        input.copyTo(output)
                        logger.info("Decompressed file ($filesdone / ${zip.size()}) [3/4]")
                        output.close()
                    }
                    input.close()
                }
            }
            zip.close()
        }

        File("${PathConstants.CACHE_PATH}cache.zip").delete()

        this.updateConstants()
    }

    private fun updateConstants() {

         logger.info("Updating constants please wait... [4/4]")

         writeFile("Items")
         writeFile("Npcs")
         writeFile("Objects")

         stopwatch.stop()

         val minutes = stopwatch.elapsed(TimeUnit.MILLISECONDS) / 1000 / 60
         val seconds = stopwatch.elapsed(TimeUnit.MILLISECONDS) / 1000 % 60

         //Set to new Verison
         logger.info("Finished updating $minutes minutes and $seconds seconds. - Server will now close please restart")
         exitProcess(status = 0)

    }

    private fun writeFile(name : String) {
        File(PathConstants.CONFIG_PATH + "$name.kt").bufferedWriter().use { out ->

            out.write("/* This file is automatically generated. Do not edit. revision = $version */\n\n")

            out.write("package io.whatever.lol123\n\n")

            out.write("object $name {\n\n")

            // data.forEach {
            out.write("     const val MAN = 345\n")
            out.write("     const val MAN_1 = 346\n")
            out.newLine()   
            //}
            out.write("}")
            out.close()
        }
    }

}
